<link rel='stylesheet' href='styles.css'/><title>Anthony Cipriano</title>
<h1 id="apl-at-its-core">APL At Its Core</h1>
<p>July 2018</p>
<p>As it is the case with all groundbreaking languages, APL is not so much a language as it is a family of ideologically related sister languages. This family includes members like Dyalog APL, A+, K, Q, and of course the relatively popular J programming language.</p>
<p>A defining property of APL languages is their level of terseness and ability to crunch not just numbers, but also bulks of data with the very same piece of code. The problem with this definition however is that terseness is not an exclusive asset of the APL family of languages and neither is vector calculation. Extremely short code and the ability to manipulate arrays of data is also commonly attributed to the WolframLanguage, but I would not consider it an APL, because the way it gets their is a whole lot different.</p>
<p>Consider the following pieces of K3 and APL code to calculate the next generation in a game of life:</p>
<pre><code>next:{|/(1;x)&amp;3 4=\:+/,/-1 0 1!&#39;\:/:-1 0 1!\:x}
next←{⊃∨/1 ⍵ ∧3 4=  +/, ¯1 0 1∘.⊖   ¯1 0 1⌽¨⊂⍵}</code></pre>
<p>As you can see these code snippets roughly resemble themselves. The special thing about these lines of code is that they contain nothing special to game of life or cellular automatons of sorts. The algorithm only consists of rotation, equality comparison, arithmetic, boolean algebra, and functional reductions. The APL code also involves boxing and unboxing arrays as they are not ordinary scalar objects, which gives it kinda a Perlish touch, but other than that the code is just using very general programming language constructs also found in Python, various Lisp dialects, or really any other remotely high level language.</p>
<p>Implementing this algorithm in any of those languages would be incrementally more verbose though and the WolframLanguage would be no exception if not for the built-in CellularAutomaton function (yes, that's a thing in the preluded standard library). This of course feels a lot like cheating as having this functionality built-in offers no general advantage to people not doing anything cellular automaton related, whereas the APL primitives are generally applicable across domains.</p>
<p>It should be clear by now that fancy semantics is not what APL is about. There really is nothing special about the above K/APL code whatsoever semantics-wise. This code could very well be transcribed to Common Lisp, but guess what: it would absolutely suck, because it may not look like that to the uninitiated, but the above line of code does a lot, and I really mean a lot.</p>
<p>Just consider the extract <code>!'\:/:</code>. The <code>!</code> operator means rotation in this context. If used as <code>n!v</code> it rotates the vector <code>v</code> by <code>n</code>. But we do not directly use the operator like that, we modify it using the adverb <code>'</code>, which generally denotes a functional map. Now we can do something like <code>n!'m</code> to rotate each row vector in the matrix <code>m</code>, that is each element of the vector of vectors <code>m</code>, by <code>n</code>, or more generally we can say something like <code>v!'m</code> to rotate each row <code>m[i]</code> in the matrix <code>m</code> by the corresponding element of <code>v[i]</code>. So whereas <code>n!m</code> would rotate the whole matrix, i.e. the columns, <code>n!'m</code> does a row rotation, but we did not stop there. We supply not one but three different rotations to perform (-1, 0, and 1), so we further amend the operator by applying the adverb map-over-left-argument (<code>\:</code>), which performs each of those three rotations separately. We also map over the right arguments (<code>/:</code>), as we actually get a vector of three different matrices supplied as the right argument.</p>
<p>So the six character excerpt <code>!'\:/:</code> would let alone be equivalent to something like <code>(lambda (v m) (map (lambda (w) (map (lambda (x) (map (lambda (u) (rotate x u)) w)) v) m)))</code> in a Lisp.</p>
<p>(As a little side note: People criticizing APL's readability tend to ignore how much a piece of APL code actually does. In proportion to that, I'd consider the K excerpt undeniably more readable than the mess this Lisp code is, even though it always fully spells out LAMBDA in plain English)</p>
<p>This does highlight that clever semantics are not the major strength of APL. To be fair, APL and J offer a great amount of moldability as they allow you to define your very own infix verbs, post-verbal adverbs, and infix conjunctions. This means you can do the following in J:</p>
<pre><code>   4^2
16
   toThePowerOf =: ^
   4 toThePowerOf 2
16</code></pre>
<p>Here we just &quot;named&quot; the power verb and use our own verb in an infix manner. This flexibility sadly makes true compilation very hard in the same way macros do, but it is not at all a defining property of the APL family.</p>
<p>K as an example does not have that flexibility: the user can very well define own functions, but not own verbs or adverbs that resemble those provided by the language. No one considers K to be the AutoLisp of APLs.</p>
<p>The real defining core of APLs is that they are not so much programming languages as they are programming notation. Take our three different maps as an example: it is totally reasonable for a programming language to provide a simple map function. Many Lisps do that. But APL is not so much about what is semantically provided as it is about what is syntactically feasible. This is why K not just provides the simple map adverb, it also provides syntax for the common case where you actually just want to map over one of the two arguments to a function. This is so common an idiom, that K provides it in the core language.</p>
<p>All of these reasons make it an absolute pleasure for me to program in APL dialects and especially in K as its evaluation model is highly influenced by Scheme (which gets its semantics right) and puts a layer of APL atop. Q is another more English like and regular syntax layer on top of K4, which I personally find nice for people learning the language, but then it is kinda too bloated at times, which makes it less appealing as a more regular K than say something like Klong.</p>
<h2 id="discuss">Discuss</h2>
<ul>
<li><a href="https://news.ycombinator.com/item?id=17534245">HackerNews</a></li>
<li><a href="https://www.reddit.com/r/programming/comments/8ysgc2/apl_at_its_core/">Reddit</a></li>
<li><a href="https://coindataflow.com/en">See this page</a>, list of Solidity projects</li>
</ul>
